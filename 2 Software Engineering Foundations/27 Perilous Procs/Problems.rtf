{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Georgia;\f2\fmodern\fcharset0 Courier;
\f3\fnil\fcharset0 Consolas;\f4\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red10\green92\blue255;
\red0\green0\blue0;\red246\green246\blue239;\red34\green34\blue34;\red157\green101\blue255;\red100\green108\blue125;
\red224\green213\blue97;\red88\green209\blue235;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c46667\c100000;
\cssrgb\c0\c0\c0\c7451;\cssrgb\c97255\c97255\c94902;\cssrgb\c17647\c17647\c17647;\cssrgb\c68235\c50588\c100000;\cssrgb\c46667\c50196\c56471;
\cssrgb\c90196\c85882\c45490;\cssrgb\c40000\c85098\c93725;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}}
\margl1440\margr1440\vieww12980\viewh20180\viewkind0
\deftab720
\pard\pardeftab720\li840\ri840\sl860\sa400\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Perilous Procs\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Let's find out how pro\'86 you are with procs! As you progress through this set of problems, the difficulty will ramp up.\
The solution is available\'a0{\field{\*\fldinst{HYPERLINK "https://aao-alpha.s3-us-west-1.amazonaws.com/assets/topics/blocks_and_procs/projects/perilous_procs_solution.rb.zip"}}{\fldrslt \cf4 \strokec4 here}}, but please do not look at it until you have attempted all of the problems!\
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 Phase 1: Problems that are pleasant.\
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\fs48 \cf2 some?\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 some?
\f1 \cb3 \'a0that accepts an array and a block as arguments. The method should return a boolean indicating whether or not at least one of the elements of the array returns true when given to the block. Solve this using\'a0
\f2 \cb5 Array#each
\f1 \cb3 .\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 p some
\f4 ?([\cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 11\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3                                 
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p some
\f4 ?([\cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 11\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3                                 
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p some
\f4 ?([\cf8 \strokec8 8\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3                                        
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p some
\f4 ?([\cf10 \strokec10 'squash'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'corn'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'kale'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'carrot'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 str
\f4 |
\f3  str
\f4 [\cf8 \strokec8 0\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 'p'
\f3 \cf6 \strokec6  
\f4 \}
\f3  
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p some
\f4 ?([\cf10 \strokec10 'squash'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'corn'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'kale'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'potato'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 str
\f4 |
\f3  str
\f4 [\cf8 \strokec8 0\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 'p'
\f3 \cf6 \strokec6  
\f4 \}
\f3  
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p some
\f4 ?([\cf10 \strokec10 'parsnip'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'lettuce'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'pea'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 str
\f4 |
\f3  str
\f4 [\cf8 \strokec8 0\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 'p'
\f3 \cf6 \strokec6  
\f4 \}
\f3         
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
exactly?\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 exactly?
\f1 \cb3 \'a0that accepts an array, a number (n), and a block as arguments. The method should return a boolean indicating whether or not there are exactly n elements that return true when given to the block. Solve this using\'a0
\f2 \cb5 Array#each
\f1 \cb3 .\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 p exactly
\f4 ?([\cf10 \strokec10 'A'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'b'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'C'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 ==
\f3  el
\f4 .
\f3 upcase 
\f4 \}
\f3          
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p exactly
\f4 ?([\cf10 \strokec10 'A'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'B'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'C'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 ==
\f3  el
\f4 .
\f3 upcase 
\f4 \}
\f3          
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p exactly
\f4 ?([\cf10 \strokec10 'A'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'B'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'C'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 ==
\f3  el
\f4 .
\f3 upcase 
\f4 \}
\f3          
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p exactly
\f4 ?([\cf10 \strokec10 'cat'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'DOG'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'bird'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 ==
\f3  el
\f4 .
\f3 upcase 
\f4 \}
\f3   
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p exactly
\f4 ?([\cf10 \strokec10 'cat'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'DOG'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'bird'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 0\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 ==
\f3  el
\f4 .
\f3 upcase 
\f4 \}
\f3   
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p exactly
\f4 ?([\cf10 \strokec10 'cat'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'dog'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'bird'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 0\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 ==
\f3  el
\f4 .
\f3 upcase 
\f4 \}
\f3   
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p exactly
\f4 ?([\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 >
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3                              
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p exactly
\f4 ?([\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 >
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3                           
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p exactly
\f4 ?([\cf8 \strokec8 42\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 9\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 6\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 >
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3                 
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
filter_out\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 filter_out
\f1 \cb3 \'a0that accepts an array and a block as arguments. The method should return a new array where elements of the original array are removed if they return true when given to the block. Solve this using\'a0
\f2 \cb5 Array#each
\f1 \cb3 .\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 p filter_out
\f4 ([\cf8 \strokec8 10\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 6\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5
\f3 \cf6 \strokec6  
\f4 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 x
\f4 |
\f3  x
\f4 .
\f3 odd
\f4 ?
\f3  
\f4 \}
\f3       
\f4 \cf9 \strokec9 # [10, 6, 2]
\f3 \cf6 \strokec6 \
p filter_out
\f4 ([\cf8 \strokec8 1\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5
\f3 \cf6 \strokec6  
\f4 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 x
\f4 |
\f3  x
\f4 .
\f3 odd
\f4 ?
\f3  
\f4 \}
\f3           
\f4 \cf9 \strokec9 # []
\f3 \cf6 \strokec6 \
p filter_out
\f4 ([\cf8 \strokec8 10\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 6\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5
\f3 \cf6 \strokec6  
\f4 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 x
\f4 |
\f3  x
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3      
\f4 \cf9 \strokec9 # [3, 5]
\f3 \cf6 \strokec6 \
p filter_out
\f4 ([\cf8 \strokec8 1\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5
\f3 \cf6 \strokec6  
\f4 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 x
\f4 |
\f3  x
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3          
\f4 \cf9 \strokec9 # [1, 7, 3, 5]
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
at_least?\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 at_least?
\f1 \cb3 \'a0that accepts an array, a number (n), and a block as an arguments. The method should return a boolean indicating whether or not at least n elements of the array return true when given to the block. Solve this using\'a0
\f2 \cb5 Array#each
\f1 \cb3 .\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 p at_least
\f4 ?([\cf10 \strokec10 'sad'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'quick'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'timid'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'final'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 end_with
\f4 ?(\cf10 \strokec10 'ly'\cf6 \strokec6 )
\f3  
\f4 \}
\f3 \
\pard\pardeftab720\sl480\partightenfactor0

\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p at_least
\f4 ?([\cf10 \strokec10 'sad'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'quickly'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'timid'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'final'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 end_with
\f4 ?(\cf10 \strokec10 'ly'\cf6 \strokec6 )
\f3  
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p at_least
\f4 ?([\cf10 \strokec10 'sad'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'quickly'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'timidly'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'final'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 end_with
\f4 ?(\cf10 \strokec10 'ly'\cf6 \strokec6 )
\f3  
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p at_least
\f4 ?([\cf10 \strokec10 'sad'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'quickly'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'timidly'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'finally'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 end_with
\f4 ?(\cf10 \strokec10 'ly'\cf6 \strokec6 )
\f3  
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p at_least
\f4 ?([\cf10 \strokec10 'sad'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'quickly'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'timid'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'final'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 end_with
\f4 ?(\cf10 \strokec10 'ly'\cf6 \strokec6 )
\f3  
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p at_least
\f4 ?([\cf10 \strokec10 'sad'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'quick'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'timid'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'final'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 end_with
\f4 ?(\cf10 \strokec10 'ly'\cf6 \strokec6 )
\f3  
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p at_least
\f4 ?([\cf11 \strokec11 false\cf6 \strokec6 ,
\f3  
\f4 \cf11 \strokec11 false\cf6 \strokec6 ,
\f3  
\f4 \cf11 \strokec11 false\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 bool
\f4 |
\f3  bool 
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p at_least
\f4 ?([\cf11 \strokec11 false\cf6 \strokec6 ,
\f3  
\f4 \cf11 \strokec11 true\cf6 \strokec6 ,
\f3  
\f4 \cf11 \strokec11 true\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 bool
\f4 |
\f3  bool 
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p at_least
\f4 ?([\cf11 \strokec11 true\cf6 \strokec6 ,
\f3  
\f4 \cf11 \strokec11 true\cf6 \strokec6 ,
\f3  
\f4 \cf11 \strokec11 true\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 bool
\f4 |
\f3  bool 
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p at_least
\f4 ?([\cf11 \strokec11 true\cf6 \strokec6 ,
\f3  
\f4 \cf11 \strokec11 true\cf6 \strokec6 ,
\f3  
\f4 \cf11 \strokec11 true\cf6 \strokec6 ,
\f3  
\f4 \cf11 \strokec11 true\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 bool
\f4 |
\f3  bool 
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
every?\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 every?
\f1 \cb3 \'a0that accepts an array and a block as arguments. The method should return a boolean indicating whether or not all elements of the array return true when given to the block. Solve this using\'a0
\f2 \cb5 Array#each
\f1 \cb3 .\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 p every
\f4 ?([\cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 11\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3                                  
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p every
\f4 ?([\cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 8\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3                                   
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p every
\f4 ?([\cf8 \strokec8 8\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3                                         
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p every
\f4 ?([\cf10 \strokec10 'squash'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'corn'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'kale'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'carrot'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 str
\f4 |
\f3  str
\f4 [\cf8 \strokec8 0\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 'p'
\f3 \cf6 \strokec6  
\f4 \}
\f3   
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p every
\f4 ?([\cf10 \strokec10 'squash'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'pea'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'kale'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'potato'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 str
\f4 |
\f3  str
\f4 [\cf8 \strokec8 0\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 'p'
\f3 \cf6 \strokec6  
\f4 \}
\f3    
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p every
\f4 ?([\cf10 \strokec10 'parsnip'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'potato'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'pea'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 str
\f4 |
\f3  str
\f4 [\cf8 \strokec8 0\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 'p'
\f3 \cf6 \strokec6  
\f4 \}
\f3           
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
at_most?\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 at_most?
\f1 \cb3 \'a0that accepts an array, a number (n), and a block as arguments. The method should return a boolean indicating whether no more than n elements of the array return true when given to the block. Solve this using\'a0
\f2 \cb5 Array#each
\f1 \cb3 .\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 p at_most
\f4 ?([-\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 100\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 3\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 >
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3                          
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p at_most
\f4 ?([-\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 100\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 3\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 >
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3                         
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p at_most
\f4 ?([\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 100\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 3\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 >
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3                           
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p at_most
\f4 ?([\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 100\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 >
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3                            
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
p at_most
\f4 ?([\cf10 \strokec10 'r'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'q'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'e'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'z'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  
\f4 \cf10 \strokec10 'aeiou'\cf6 \strokec6 .
\f3 include
\f4 ?(
\f3 el
\f4 )
\f3  
\f4 \}
\f3     
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p at_most
\f4 ?([\cf10 \strokec10 'r'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'i'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'e'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'z'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  
\f4 \cf10 \strokec10 'aeiou'\cf6 \strokec6 .
\f3 include
\f4 ?(
\f3 el
\f4 )
\f3  
\f4 \}
\f3     
\f4 \cf9 \strokec9 # true
\f3 \cf6 \strokec6 \
p at_most
\f4 ?([\cf10 \strokec10 'r'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'i'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'e'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'o'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  
\f4 \cf10 \strokec10 'aeiou'\cf6 \strokec6 .
\f3 include
\f4 ?(
\f3 el
\f4 )
\f3  
\f4 \}
\f3     
\f4 \cf9 \strokec9 # false
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
first_index\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 first_index
\f1 \cb3 \'a0that accepts an array and a block as arguments. The method should return the index of the first element of the array that returns true when giben to the block. If no element of returns true, then the method should return nil. Solve this using\'a0
\f2 \cb5 Array#each
\f1 \cb3 .\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 p first_index
\f4 ([\cf10 \strokec10 'bit'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'cat'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'byte'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'below'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el
\f4 .
\f3 length 
\f4 >
\f3  
\f4 \cf8 \strokec8 3
\f3 \cf6 \strokec6  
\f4 \}
\f3            
\f4 \cf9 \strokec9 # 2
\f3 \cf6 \strokec6 \
p first_index
\f4 ([\cf10 \strokec10 'bitten'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'bit'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'cat'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'byte'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'below'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el
\f4 .
\f3 length 
\f4 >
\f3  
\f4 \cf8 \strokec8 3
\f3 \cf6 \strokec6  
\f4 \}
\f3  
\f4 \cf9 \strokec9 # 0
\f3 \cf6 \strokec6 \
p first_index
\f4 ([\cf10 \strokec10 'bitten'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'bit'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'cat'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'byte'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'below'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el
\f4 .
\f3 length 
\f4 >
\f3  
\f4 \cf8 \strokec8 6
\f3 \cf6 \strokec6  
\f4 \}
\f3  
\f4 \cf9 \strokec9 # nil
\f3 \cf6 \strokec6 \
p first_index
\f4 ([\cf10 \strokec10 'bit'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'cat'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'byte'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'below'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el
\f4 [\cf8 \strokec8 0\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 'b'
\f3 \cf6 \strokec6  
\f4 \}
\f3             
\f4 \cf9 \strokec9 # 0
\f3 \cf6 \strokec6 \
p first_index
\f4 ([\cf10 \strokec10 'bit'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'cat'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'byte'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'below'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el
\f4 .
\f3 include
\f4 ?(\cf10 \strokec10 'a'\cf6 \strokec6 )
\f3  
\f4 \}
\f3         
\f4 \cf9 \strokec9 # 1
\f3 \cf6 \strokec6 \
p first_index
\f4 ([\cf10 \strokec10 'bit'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'cat'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'byte'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'below'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el
\f4 [\cf8 \strokec8 0\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 't'
\f3 \cf6 \strokec6  
\f4 \}
\f3             
\f4 \cf9 \strokec9 # nil
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 \cb3 \strokec2 \
Phase 2: The proc thickens.\
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\fs48 \cf2 xnor_select\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 xnor_select
\f1 \cb3 \'a0that accepts an array and two procs as arguments. The method should return a new array containing elements of the original array that either return true for both procs or return false for both procs.\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 is_even 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 %
\f3  
\f4 \cf8 \strokec8 2
\f3 \cf6 \strokec6  
\f4 ==
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
is_odd 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 %
\f3  
\f4 \cf8 \strokec8 2
\f3 \cf6 \strokec6  
\f4 !=
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
is_positive 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 >
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
p xnor_select
\f4 ([\cf8 \strokec8 8\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 5\cf6 \strokec6 ],
\f3  is_even
\f4 ,
\f3  is_positive
\f4 )
\f3          
\f4 \cf9 \strokec9 # [8, -5]
\f3 \cf6 \strokec6 \
p xnor_select
\f4 ([-\cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 13\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 12\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 10\cf6 \strokec6 ],
\f3  is_even
\f4 ,
\f3  is_positive
\f4 )
\f3   
\f4 \cf9 \strokec9 # [-7, -13, 12]
\f3 \cf6 \strokec6 \
p xnor_select
\f4 ([-\cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 13\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 12\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 10\cf6 \strokec6 ],
\f3  is_odd
\f4 ,
\f3  is_positive
\f4 )
\f3    
\f4 \cf9 \strokec9 # [5, -10]
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
filter_out!\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Rewrite your previous\'a0
\f2 \cb5 filter_out
\f1 \cb3 \'a0method to mutate the input array instead of returning a new array. That is, write a method\'a0
\f2 \cb5 filter_out!
\f1 \cb3 \'a0that accepts an array and a block as args. The method should remove elements of the input array that return true when given to the block. Solve this without using\'a0
\f2 \cb5 Array.reject!
\f1 \cb3 .\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 arr_1 
\f4 =
\f3  
\f4 [\cf8 \strokec8 10\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 6\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5
\f3 \cf6 \strokec6  
\f4 ]
\f3 \
filter_out
\f4 !(
\f3 arr_1
\f4 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 x
\f4 |
\f3  x
\f4 .
\f3 odd
\f4 ?
\f3  
\f4 \}
\f3 \
p arr_1     
\f4 \cf9 \strokec9 # [10, 6, 2]
\f3 \cf6 \strokec6 \
\
arr_2 
\f4 =
\f3  
\f4 [\cf8 \strokec8 1\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5
\f3 \cf6 \strokec6  
\f4 ]
\f3 \
filter_out
\f4 !(
\f3 arr_2
\f4 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 x
\f4 |
\f3  x
\f4 .
\f3 odd
\f4 ?
\f3  
\f4 \}
\f3 \
p arr_2     
\f4 \cf9 \strokec9 # []
\f3 \cf6 \strokec6 \
\
arr_3 
\f4 =
\f3  
\f4 [\cf8 \strokec8 10\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 6\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5
\f3 \cf6 \strokec6  
\f4 ]
\f3 \
filter_out
\f4 !(
\f3 arr_3
\f4 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 x
\f4 |
\f3  x
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3 \
p arr_3     
\f4 \cf9 \strokec9 # [3, 5]
\f3 \cf6 \strokec6 \
\
arr_4 
\f4 =
\f3  
\f4 [\cf8 \strokec8 1\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5
\f3 \cf6 \strokec6  
\f4 ]
\f3 \
filter_out
\f4 !([\cf8 \strokec8 1\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5
\f3 \cf6 \strokec6  
\f4 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 x
\f4 |
\f3  x
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3 \
p arr_4 
\f4 \cf9 \strokec9 # [1, 7, 3, 5]
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
multi_map\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 multi_map
\f1 \cb3 \'a0that accepts an array, an optional number (n), and a block as arguments. The method should return a new array where each element of the original array is repeatedly run through the block n times. If the number argument is not passed in, then the the elements should be run through the block once.\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 p multi_map
\f4 ([\cf10 \strokec10 'pretty'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'cool'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'huh?'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s 
\f4 +
\f3  
\f4 \cf10 \strokec10 '!'\cf6 \strokec6 \}
\f3       
\f4 \cf9 \strokec9 # ["pretty!", "cool!", "huh?!"]
\f3 \cf6 \strokec6 \
p multi_map
\f4 ([\cf10 \strokec10 'pretty'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'cool'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'huh?'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s 
\f4 +
\f3  
\f4 \cf10 \strokec10 '!'\cf6 \strokec6 \}
\f3    
\f4 \cf9 \strokec9 # ["pretty!", "cool!", "huh?!"]
\f3 \cf6 \strokec6 \
p multi_map
\f4 ([\cf10 \strokec10 'pretty'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'cool'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'huh?'\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s 
\f4 +
\f3  
\f4 \cf10 \strokec10 '!'\cf6 \strokec6 \}
\f3    
\f4 \cf9 \strokec9 # ["pretty!!!", "cool!!!", "huh?!!!"]
\f3 \cf6 \strokec6 \
p multi_map
\f4 ([\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 num
\f4 |
\f3  num 
\f4 *
\f3  
\f4 \cf8 \strokec8 10
\f3 \cf6 \strokec6  
\f4 \}
\f3              
\f4 \cf9 \strokec9 # [40, 30, 20, 70]
\f3 \cf6 \strokec6 \
p multi_map
\f4 ([\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 num
\f4 |
\f3  num 
\f4 *
\f3  
\f4 \cf8 \strokec8 10
\f3 \cf6 \strokec6  
\f4 \}
\f3              
\f4 \cf9 \strokec9 # [400, 300, 200, 700]
\f3 \cf6 \strokec6 \
p multi_map
\f4 ([\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ],
\f3  
\f4 \cf8 \strokec8 4\cf6 \strokec6 )
\f3  
\f4 \{
\f3  
\f4 |
\f3 num
\f4 |
\f3  num 
\f4 *
\f3  
\f4 \cf8 \strokec8 10
\f3 \cf6 \strokec6  
\f4 \}
\f3              
\f4 \cf9 \strokec9 # [40000, 30000, 20000, 70000]
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
proctition\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 proctition
\f1 \cb3 \'a0that accepts an array and a block as arguments. The method should return a new array where the elements that return true when given to the block come before all of the elements that return false when given to the block. This means that the new array has two partitions; the order among elements in the same partition should be the same as their relative order in the input array.\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 p proctition
\f4 ([\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 5\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 10\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 1\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el 
\f4 >
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
\pard\pardeftab720\sl480\partightenfactor0

\f4 \cf9 \strokec9 # [4, 7, 1, 3, -5, -10, -2]
\f3 \cf6 \strokec6 \
\
p proctition
\f4 ([\cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 8\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 3\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 6\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 10\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 el
\f4 |
\f3  el
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # [8, 6, 10, 7, 3]
\f3 \cf6 \strokec6 \
\
p proctition
\f4 ([\cf10 \strokec10 'cat'\cf6 \strokec6 ,\cf10 \strokec10 'boot'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'dog'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'bug'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'boat'\cf6 \strokec6 ])
\f3  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 [\cf8 \strokec8 0\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 'b'
\f3 \cf6 \strokec6  
\f4 \}
\f3 \

\f4 \cf9 \strokec9 # ["boot", "bug", "boat", "cat", "dog"]
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 \cb3 \strokec2 \
Phase 3: Perilous.\
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\fs48 \cf2 selected_map!\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 selected_map!
\f1 \cb3 \'a0that accepts an array and two procs as arguments. The method should replace the elements that return true when passed into the first proc with their return values when they are passed into the second proc. This method should mutate the input array and return nil.\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 is_even 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n
\f4 .
\f3 even
\f4 ?
\f3  
\f4 \}
\f3 \
is_positive 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 >
\f3  
\f4 \cf8 \strokec8 0
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
square 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 *
\f3  n 
\f4 \}
\f3 \
flip_sign 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  
\f4 -
\f3 n 
\f4 \}
\f3 \
\
arr_1 
\f4 =
\f3  
\f4 [\cf8 \strokec8 8\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 5\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 10\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 4\cf6 \strokec6 ]
\f3 \
p selected_map
\f4 !(
\f3 arr_1
\f4 ,
\f3  is_even
\f4 ,
\f3  square
\f4 )
\f3      
\f4 \cf9 \strokec9 # nil
\f3 \cf6 \strokec6 \
p arr_1                                     
\f4 \cf9 \strokec9 # [64, 5, 100, 16]
\f3 \cf6 \strokec6 \
\
arr_2 
\f4 =
\f3  
\f4 [-\cf8 \strokec8 10\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 6\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 9\cf6 \strokec6 ]
\f3 \
p selected_map
\f4 !(
\f3 arr_2
\f4 ,
\f3  is_even
\f4 ,
\f3  flip_sign
\f4 )
\f3   
\f4 \cf9 \strokec9 # nil
\f3 \cf6 \strokec6 \
p arr_2                                     
\f4 \cf9 \strokec9 # [10, -4, 7, -6, 2, -9]
\f3 \cf6 \strokec6 \
\
arr_3 
\f4 =
\f3  
\f4 [-\cf8 \strokec8 10\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 7\cf6 \strokec6 ,
\f3  
\f4 \cf8 \strokec8 6\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 2\cf6 \strokec6 ,
\f3  
\f4 -\cf8 \strokec8 9\cf6 \strokec6 ]
\f3 \
p selected_map
\f4 !(
\f3 arr_3
\f4 ,
\f3  is_positive
\f4 ,
\f3  square
\f4 )
\f3  
\f4 \cf9 \strokec9 # nil
\f3 \cf6 \strokec6 \
p arr_3                                     
\f4 \cf9 \strokec9 # [-10, 16, 49, 36, -2, -9]
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
chain_map\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method that accepts any value and an array of procs as an argument. The method should return the final result of feeding the value through all of the procs. For example, if the array contains three procs, then:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl440\sa100\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 the value is given to the first proc\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 the result of the first proc is given to the second proc\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 the result of the second proc is given to the third proc\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 the result of third proc is the final result\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0
\cf2 \cb3 Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 add_5 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 +
\f3  
\f4 \cf8 \strokec8 5
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
half 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 /
\f3  
\f4 \cf8 \strokec8 2.0
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
square 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 n
\f4 |
\f3  n 
\f4 *
\f3  n 
\f4 \}
\f3 \
\
p chain_map
\f4 (\cf8 \strokec8 25\cf6 \strokec6 ,
\f3  
\f4 [
\f3 add_5
\f4 ,
\f3  half
\f4 ])
\f3           
\f4 \cf9 \strokec9 # 15.0
\f3 \cf6 \strokec6 \
p chain_map
\f4 (\cf8 \strokec8 25\cf6 \strokec6 ,
\f3  
\f4 [
\f3 half
\f4 ,
\f3  add_5
\f4 ])
\f3           
\f4 \cf9 \strokec9 # 17.5
\f3 \cf6 \strokec6 \
p chain_map
\f4 (\cf8 \strokec8 25\cf6 \strokec6 ,
\f3  
\f4 [
\f3 add_5
\f4 ,
\f3  half
\f4 ,
\f3  square
\f4 ])
\f3   
\f4 \cf9 \strokec9 # 225
\f3 \cf6 \strokec6 \
p chain_map
\f4 (\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 [
\f3 square
\f4 ,
\f3  half
\f4 ])
\f3           
\f4 \cf9 \strokec9 # 8
\f3 \cf6 \strokec6 \
p chain_map
\f4 (\cf8 \strokec8 4\cf6 \strokec6 ,
\f3  
\f4 [
\f3 half
\f4 ,
\f3  square
\f4 ])
\f3           
\f4 \cf9 \strokec9 # 4
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
proc_suffix\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 proc_suffix
\f1 \cb3 \'a0that accepts a sentence and a hash as arguments. The hash contains procs as keys and suffix strings as values. The method should return a new sentence where each word of the original sentence is appended with a suffix if the\'a0
\b original
\b0 \'a0word returns true when given to the corresponding proc key. If an original word returns true for multiple procs, then the suffixes should be appended in the order that they appear in the input hash.\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 contains_a 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 w
\f4 |
\f3  w
\f4 .
\f3 include
\f4 ?(\cf10 \strokec10 'a'\cf6 \strokec6 )
\f3  
\f4 \}
\f3 \
three_letters 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 w
\f4 |
\f3  w
\f4 .
\f3 length 
\f4 ==
\f3  
\f4 \cf8 \strokec8 3
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
four_letters 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 w
\f4 |
\f3  w
\f4 .
\f3 length 
\f4 ==
\f3  
\f4 \cf8 \strokec8 4
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
\
p proc_suffix
\f4 (\cf10 \strokec10 'dog cat'\cf6 \strokec6 ,
\f3 \
    contains_a 
\f4 =>
\f3  
\f4 \cf10 \strokec10 'ly'\cf6 \strokec6 ,
\f3 \
    three_letters 
\f4 =>
\f3  
\f4 \cf10 \strokec10 'o'
\f3 \cf6 \strokec6 \
\pard\pardeftab720\sl480\partightenfactor0

\f4 \cf6 )
\f3    
\f4 \cf9 \strokec9 # "dogo catlyo"
\f3 \cf6 \strokec6 \
\
p proc_suffix
\f4 (\cf10 \strokec10 'dog cat'\cf6 \strokec6 ,
\f3 \
    three_letters 
\f4 =>
\f3  
\f4 \cf10 \strokec10 'o'\cf6 \strokec6 ,
\f3 \
    contains_a 
\f4 =>
\f3  
\f4 \cf10 \strokec10 'ly'
\f3 \cf6 \strokec6 \

\f4 )
\f3    
\f4 \cf9 \strokec9 # "dogo catoly"
\f3 \cf6 \strokec6 \
\
p proc_suffix
\f4 (\cf10 \strokec10 'wrong glad cat'\cf6 \strokec6 ,
\f3 \
    contains_a 
\f4 =>
\f3  
\f4 \cf10 \strokec10 'ly'\cf6 \strokec6 ,
\f3 \
    three_letters 
\f4 =>
\f3  
\f4 \cf10 \strokec10 'o'\cf6 \strokec6 ,
\f3 \
    four_letters 
\f4 =>
\f3  
\f4 \cf10 \strokec10 'ing'
\f3 \cf6 \strokec6 \

\f4 )
\f3    
\f4 \cf9 \strokec9 # "wrong gladlying catlyo"
\f3 \cf6 \strokec6 \
\
p proc_suffix
\f4 (\cf10 \strokec10 'food glad rant dog cat'\cf6 \strokec6 ,
\f3 \
    four_letters 
\f4 =>
\f3  
\f4 \cf10 \strokec10 'ing'\cf6 \strokec6 ,
\f3 \
    contains_a 
\f4 =>
\f3  
\f4 \cf10 \strokec10 'ly'\cf6 \strokec6 ,
\f3 \
    three_letters 
\f4 =>
\f3  
\f4 \cf10 \strokec10 'o'
\f3 \cf6 \strokec6 \

\f4 )
\f3    
\f4 \cf9 \strokec9 # "fooding gladingly rantingly dogo catlyo"
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
proctition_platinum\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 proctition_platinum
\f1 \cb3 \'a0that accepts an array and any number of additional procs as arguments. The method should return a hash where the keys correspond to the number of procs passed in.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl440\sa100\partightenfactor0
\ls2\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 For example, if three procs are passed in, then the hash should have the keys 1, 2, and 3.\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0
\cf2 \cb3 The values associated with each key should be an array containing the elements of the input array that return true when passed into the corresponding proc.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl440\sa100\partightenfactor0
\ls3\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 For example, this means that the array that corresponds to the key 2 should contain the elements that return true when passed into the second proc.\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0
\cf2 \cb3 If an element returns true for multiple procs, then it should only be placed into the array that corresponds to the proc that appears first in the arguments.\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 is_yelled 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 [-\cf8 \strokec8 1\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 '!'
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
is_upcase 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 upcase 
\f4 ==
\f3  s 
\f4 \}
\f3 \
contains_a 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 downcase
\f4 .
\f3 include
\f4 ?(\cf10 \strokec10 'a'\cf6 \strokec6 )
\f3  
\f4 \}
\f3 \
begins_w 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 downcase
\f4 [\cf8 \strokec8 0\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 'w'
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
\
p proctition_platinum
\f4 ([\cf10 \strokec10 'WHO'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'what'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'when!'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'WHERE!'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'how'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'WHY'\cf6 \strokec6 ],
\f3  is_yelled
\f4 ,
\f3  contains_a
\f4 )
\f3 \
\pard\pardeftab720\sl480\partightenfactor0

\f4 \cf9 \strokec9 # \{1=>["when!", "WHERE!"], 2=>["what"]\}
\f3 \cf6 \strokec6 \
\
p proctition_platinum
\f4 ([\cf10 \strokec10 'WHO'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'what'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'when!'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'WHERE!'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'how'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'WHY'\cf6 \strokec6 ],
\f3  is_yelled
\f4 ,
\f3  is_upcase
\f4 ,
\f3  contains_a
\f4 )
\f3 \

\f4 \cf9 \strokec9 # \{1=>["when!", "WHERE!"], 2=>["WHO", "WHY"], 3=>["what"]\}
\f3 \cf6 \strokec6 \
\
p proctition_platinum
\f4 ([\cf10 \strokec10 'WHO'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'what'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'when!'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'WHERE!'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'how'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'WHY'\cf6 \strokec6 ],
\f3  is_upcase
\f4 ,
\f3  is_yelled
\f4 ,
\f3  contains_a
\f4 )
\f3 \

\f4 \cf9 \strokec9 # \{1=>["WHO", "WHERE!", "WHY"], 2=>["when!"], 3=>["what"]\}
\f3 \cf6 \strokec6 \
\
p proctition_platinum
\f4 ([\cf10 \strokec10 'WHO'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'what'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'when!'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'WHERE!'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'how'\cf6 \strokec6 ,
\f3  
\f4 \cf10 \strokec10 'WHY'\cf6 \strokec6 ],
\f3  begins_w
\f4 ,
\f3  is_upcase
\f4 ,
\f3  is_yelled
\f4 ,
\f3  contains_a
\f4 )
\f3 \

\f4 \cf9 \strokec9 # \{1=>["WHO", "what", "when!", "WHERE!", "WHY"], 2=>[], 3=>[], 4=>[]\}
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
procipher\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 procipher
\f1 \cb3 \'a0that accepts a sentence and a hash as arguments. The hash contains procs as both keys and values. The method should return a new sentence where each word of the input sentence is changed by a value proc if the\'a0
\b original
\b0 \'a0word returns true when passed into the key proc. If an original word returns true for multiple key procs, then the value proc changes should be applied in the order that they appear in the hash.\
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 is_yelled 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 [-\cf8 \strokec8 1\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 '!'
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
is_upcase 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 upcase 
\f4 ==
\f3  s 
\f4 \}
\f3 \
contains_a 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 downcase
\f4 .
\f3 include
\f4 ?(\cf10 \strokec10 'a'\cf6 \strokec6 )
\f3  
\f4 \}
\f3 \
make_question 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s 
\f4 +
\f3  
\f4 \cf10 \strokec10 '???'
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
reverse 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 reverse 
\f4 \}
\f3 \
add_smile 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s 
\f4 +
\f3  
\f4 \cf10 \strokec10 ':)'
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
\
p procipher
\f4 (\cf10 \strokec10 'he said what!'\cf6 \strokec6 ,
\f3 \
    is_yelled 
\f4 =>
\f3  make_question
\f4 ,
\f3 \
    contains_a 
\f4 =>
\f3  reverse\
\pard\pardeftab720\sl480\partightenfactor0

\f4 \cf6 )
\f3  
\f4 \cf9 \strokec9 # "he dias ???!tahw"
\f3 \cf6 \strokec6 \
\
p procipher
\f4 (\cf10 \strokec10 'he said what!'\cf6 \strokec6 ,
\f3 \
    contains_a 
\f4 =>
\f3  reverse
\f4 ,
\f3 \
    is_yelled 
\f4 =>
\f3  make_question\

\f4 )
\f3  
\f4 \cf9 \strokec9 # "he dias !tahw???"
\f3 \cf6 \strokec6 \
\
p procipher
\f4 (\cf10 \strokec10 'he said what!'\cf6 \strokec6 ,
\f3 \
    contains_a 
\f4 =>
\f3  reverse
\f4 ,
\f3 \
    is_yelled 
\f4 =>
\f3  add_smile\

\f4 )
\f3  
\f4 \cf9 \strokec9 # "he dias !tahw:)"
\f3 \cf6 \strokec6 \
\
p procipher
\f4 (\cf10 \strokec10 'stop that taxi now'\cf6 \strokec6 ,
\f3 \
    is_upcase 
\f4 =>
\f3  add_smile
\f4 ,
\f3 \
    is_yelled 
\f4 =>
\f3  reverse
\f4 ,
\f3 \
    contains_a 
\f4 =>
\f3  make_question\

\f4 )
\f3  
\f4 \cf9 \strokec9 # "stop that??? taxi??? now"
\f3 \cf6 \strokec6 \
\
p procipher
\f4 (\cf10 \strokec10 'STOP that taxi now!'\cf6 \strokec6 ,
\f3 \
    is_upcase 
\f4 =>
\f3  add_smile
\f4 ,
\f3 \
    is_yelled 
\f4 =>
\f3  reverse
\f4 ,
\f3 \
    contains_a 
\f4 =>
\f3  make_question\

\f4 )
\f3  
\f4 \cf9 \strokec9 # "STOP:) that??? taxi??? !won"
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 \strokec2 \
picky_procipher\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Write a method\'a0
\f2 \cb5 picky_procipher
\f1 \cb3 \'a0that accepts a sentence and a hash as arguments. The hash contains procs as both keys and values. The method should return a new sentence where each word of the input sentence is changed by a value proc if the\'a0
\b original
\b0 \'a0word returns true when passed into the key proc.\'a0
\i If an original word returns true for multiple key procs, then only the value proc that appears earliest in the hash should be applied.
\i0 \
Examples\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf6 \cb7 \strokec6 is_yelled 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 [-\cf8 \strokec8 1\cf6 \strokec6 ]
\f3  
\f4 ==
\f3  
\f4 \cf10 \strokec10 '!'
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
is_upcase 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 upcase 
\f4 ==
\f3  s 
\f4 \}
\f3 \
contains_a 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 downcase
\f4 .
\f3 include
\f4 ?(\cf10 \strokec10 'a'\cf6 \strokec6 )
\f3  
\f4 \}
\f3 \
make_question 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s 
\f4 +
\f3  
\f4 \cf10 \strokec10 '???'
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
reverse 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s
\f4 .
\f3 reverse 
\f4 \}
\f3 \
add_smile 
\f4 =
\f3  
\f4 \cf8 \strokec8 Proc\cf6 \strokec6 .\cf11 \strokec11 new
\f3 \cf6 \strokec6  
\f4 \{
\f3  
\f4 |
\f3 s
\f4 |
\f3  s 
\f4 +
\f3  
\f4 \cf10 \strokec10 ':)'
\f3 \cf6 \strokec6  
\f4 \}
\f3 \
\
p picky_procipher
\f4 (\cf10 \strokec10 'he said what!'\cf6 \strokec6 ,
\f3 \
    is_yelled 
\f4 =>
\f3  make_question
\f4 ,
\f3 \
    contains_a 
\f4 =>
\f3  reverse\
\pard\pardeftab720\sl480\partightenfactor0

\f4 \cf6 )
\f3  
\f4 \cf9 \strokec9 # "he dias what!???"
\f3 \cf6 \strokec6 \
\
p picky_procipher
\f4 (\cf10 \strokec10 'he said what!'\cf6 \strokec6 ,
\f3 \
    contains_a 
\f4 =>
\f3  reverse
\f4 ,
\f3 \
    is_yelled 
\f4 =>
\f3  make_question\

\f4 )
\f3  
\f4 \cf9 \strokec9 # "he dias !tahw"
\f3 \cf6 \strokec6 \
\
p picky_procipher
\f4 (\cf10 \strokec10 'he said what!'\cf6 \strokec6 ,
\f3 \
    contains_a 
\f4 =>
\f3  reverse
\f4 ,
\f3 \
    is_yelled 
\f4 =>
\f3  add_smile\

\f4 )
\f3  
\f4 \cf9 \strokec9 # "he dias !tahw"
\f3 \cf6 \strokec6 \
\
p picky_procipher
\f4 (\cf10 \strokec10 'stop that taxi now'\cf6 \strokec6 ,
\f3 \
    is_upcase 
\f4 =>
\f3  add_smile
\f4 ,
\f3 \
    is_yelled 
\f4 =>
\f3  reverse
\f4 ,
\f3 \
    contains_a 
\f4 =>
\f3  make_question\

\f4 )
\f3  
\f4 \cf9 \strokec9 # "stop that??? taxi??? now"
\f3 \cf6 \strokec6 \
\
p picky_procipher
\f4 (\cf10 \strokec10 'STOP that taxi!'\cf6 \strokec6 ,
\f3 \
    is_upcase 
\f4 =>
\f3  add_smile
\f4 ,
\f3 \
    is_yelled 
\f4 =>
\f3  reverse
\f4 ,
\f3 \
    contains_a 
\f4 =>
\f3  make_question\

\f4 )
\f3  
\f4 \cf9 \strokec9 # "STOP:) that??? !ixat"
\f3 \cf6 \strokec6 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\fs40 \cf2 \cb3 \strokec2 \'86 pun intended\
}