{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Georgia;\f2\fmodern\fcharset0 Courier;
\f3\fnil\fcharset0 AppleColorEmoji;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red10\green92\blue255;\red0\green0\blue0;
}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c46667\c100000;\cssrgb\c0\c0\c0\c7451;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid102\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid302\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{square\}}{\leveltext\leveltemplateid303\'01\uc0\u9642 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listname ;}\listid4}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}}
\margl1440\margr1440\vieww10700\viewh15520\viewkind0
\deftab720
\pard\pardeftab720\li840\ri840\sl860\sa400\partightenfactor0

\f0\b\fs72 \cf2 \expnd0\expndtw0\kerning0
Ghost\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Today we'll be writing a Ruby implementation of everyone's (or maybe just my) favorite road-trip word game,\'a0{\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/Ghost_(game)"}}{\fldrslt \cf3 Ghost}}.\
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 Learning Goals\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl680\sa100\partightenfactor0
\ls1\ilvl0
\f1\b0\fs40 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Understand how different classes interact\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Be able to write classes in different files and use\'a0
\f2 \cb4 require_relative
\f1 \cb1 \'a0to connect them\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Know how to test methods in pry\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Know how to read lines from a text file\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Understand how\'a0
\f2 \cb4 __FILE__ == $PROGRAM_NAME
\f1 \cb1 \'a0works\
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 \
Phase 1: Playing a Single Round\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Let's start by writing the logic to play a single round of Ghost (that is, playing until one player spells a word). Write your game for two players only, and don't worry about keeping track of wins/losses (we can get to this later). The basic logic will look something like this:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl680\sa100\partightenfactor0
\ls2\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Instantiate a new Game object, passing in both of the Players.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl680\sa100\partightenfactor0
\ls2\ilvl1\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
The Game maintains a\'a0
\f2 \cb4 fragment
\f1 \cb1 \'a0instance variable, which represents the word as it has been built up by the players.\
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
The Players take turns adding a letter to the\'a0
\f2 \cb4 fragment
\f1 \cb1 . The Game should ensure that a play is valid before actually changing the\'a0
\f2 \cb4 fragment
\f1 \cb1 .\
\ls2\ilvl1\kerning1\expnd0\expndtw0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
The Game checks the\'a0
\f2 \cb4 fragment
\f1 \cb1 \'a0against a\'a0
\f2 \cb4 dictionary
\f1 \cb1 ; if the\'a0
\f2 \cb4 fragment
\f1 \cb1 \'a0is a word contained in the\'a0
\f2 \cb4 dictionary
\f1 \cb1 , then the previous player loses.\
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \
Game\
\pard\pardeftab720\li840\ri840\sl480\sa400\partightenfactor0

\f2\b0\fs40 \cf2 \cb4 #initialize
\f0\b \cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0 \cf2 Assign instance variables for the\'a0
\f2 \cb4 players
\f1 \cb1 ,\'a0
\f2 \cb4 fragment
\f1 \cb1 , and\'a0
\f2 \cb4 dictionary
\f1 \cb1 . Since we'll be checking the\'a0
\f2 \cb4 fragment
\f1 \cb1 \'a0for inclusion in the\'a0
\f2 \cb4 dictionary
\f1 \cb1 , we'll want to use a data structure with fast lookup: a Hash or\'a0{\field{\*\fldinst{HYPERLINK "http://ruby-doc.org/stdlib-2.4.2/libdoc/set/rdoc/Set.html"}}{\fldrslt \cf3 Set}}\'a0would be ideal. You can use\'a0{\field{\*\fldinst{HYPERLINK "https://assets.aaonline.io/fullstack/ruby/projects/ghost/dictionary.txt"}}{\fldrslt \cf3 this file}}\'a0to populate your dictionary; it contains only words three letters or longer (otherwise we wouldn't have a very interesting game).\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f3 \cf2 \uc0\u55357 \u56481 
\f1 \'a0
\i NOTE:
\i0 \'a0Using a Hash or a Set instead of an Array to store our dictionary allows us to very quickly check if the fragment is included in the dictionary. In fact, the amount of time it would take to see if the fragment was included would be independent of how long the dictionary is because these data structures don't require you to examine every element when you are checking for inclusion. If we stored the dictionary just as an array of strings, using the\'a0
\f2 \cb4 Array#include?
\f1 \cb1 \'a0method would take longer as our array of got longer. Keep in mind that when you are then checking to see if there are any words in the dictionary that can be created by adding another letter to the fragment in your\'a0
\f2 \cb4 valid_play?
\f1 \cb1 \'a0method, you are potentially looking at every word in the dictionary. Therefore, this operation will not be speed-boosted by our use of a Set or Hash.\
\pard\pardeftab720\li840\ri840\sl480\sa400\partightenfactor0

\f2 \cf2 \cb4 #play_round
\f0\b \cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0 \cf2 The core game logic lives here. I wrote a number of helper methods to keep things clean:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl680\sa100\partightenfactor0
\ls3\ilvl0
\f2 \cf2 \cb4 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
#current_player
\f1 \cb1 \
\ls3\ilvl0
\f2 \cb4 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
#previous_player
\f1 \cb1 \
\ls3\ilvl0
\f2 \cb4 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
#next_player!
\f1 \cb1 : updates the\'a0
\f2 \cb4 current_player
\f1 \cb1 \'a0and\'a0
\f2 \cb4 previous_player
\f1 \cb1 \
\ls3\ilvl0
\f2 \cb4 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
#take_turn(player)
\f1 \cb1 : gets a string from the player until a valid play is made; then updates the fragment and checks against the dictionary. You may also want to alert the player if they attempt to make an invalid move (or, if you're feeling mean, you might cause them to lose outright).\
\ls3\ilvl0
\f2 \cb4 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
#valid_play?(string)
\f1 \cb1 : Checks that\'a0
\f2 \cb4 string
\f1 \cb1 \'a0is a letter of the alphabet and that there are words we can spell after adding it to the\'a0
\f2 \cb4 fragment
\f1 \cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \
Player\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 I wrote\'a0
\f2 \cb4 initialize
\f1 \cb1 ,\'a0
\f2 \cb4 guess
\f1 \cb1 , and\'a0
\f2 \cb4 alert_invalid_guess
\f1 \cb1 \'a0methods. You'll probably want each\'a0
\f2 \cb4 Player
\f1 \cb1 \'a0to have a\'a0
\f2 \cb4 name
\f1 \cb1 , as well.\
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 Phase 2: Playing a Full Game\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Now that we have the logic to play a single round of Ghost, we'll have to add another layer.\
\pard\pardeftab720\li840\ri840\sl480\sa400\partightenfactor0

\f2 \cf2 \cb4 Game#losses
\f0\b \cb1 \'a0and\'a0
\f2\b0 \cb4 Game#record
\f0\b \cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0 \cf2 In a game of Ghost, a player "earns" a letter each time they lose a round. Thus, if Eric beats Ryan 3 times and loses once, then Eric has a "G" and Ryan has a "GHO". If a player spells the word "GHOST", they are eliminated from play (and in the case of two players, the other player wins).\
I added a\'a0
\f2 \cb4 losses
\f1 \cb1 \'a0hash to my Game class. The keys to the hash are\'a0
\f2 \cb4 Player
\f1 \cb1 s, and the values are the number of games that player has lost. Update this at the end of\'a0
\f2 \cb4 #play_round
\f1 \cb1 . For flavor, I also wrote a helper method,\'a0
\f2 \cb4 #record(player)
\f1 \cb1 , that translates a player's losses into a substring of "GHOST".\
\pard\pardeftab720\li840\ri840\sl480\sa400\partightenfactor0

\f2 \cf2 \cb4 Game#run
\f0\b \cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0 \cf2 This method should call\'a0
\f2 \cb4 #play_round
\f1 \cb1 \'a0until one of the players reaches 5 losses ("GHOST"). I wrote a helper method,\'a0
\f2 \cb4 #display_standings
\f1 \cb1 , to show the scoreboard at the beginning of each round. Remember to reset the fragment at the beginning of each round, as well!\
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 Phase 3: Multiplayer!\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Refactor your game to work with more than just two players. Instead of ending the game when one of the players reaches five losses, simply exclude that player from further rounds. End the game when only one player is left standing.\'a0
\b Hint
\b0 : You won't be able to use an instance variable for each player anymore. What data structure might we use as an alternative?\
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 Phase Bonus\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl680\sa100\partightenfactor0
\ls4\ilvl0
\f1\b0\fs40 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Write an\'a0
\f2 \cb4 AiPlayer
\f1 \cb1 \'a0class for your Ghost game. You'll need to figure out the logic for picking a winning letter on each turn. In order to do this, your\'a0
\f2 \cb4 AiPlayer
\f1 \cb1 \'a0will need to know both the current fragment and the number of other players (
\f2 \cb4 n
\f1 \cb1 ).\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl680\sa100\partightenfactor0
\ls4\ilvl1\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
If adding a letter to the fragment would spell a word, then the letter is a losing move.\
\ls4\ilvl1\kerning1\expnd0\expndtw0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
If adding a letter to the fragment would leave only words with\'a0
\f2 \cb4 n
\f1 \cb1 \'a0or fewer additional letters as possibilities, then the letter is a winning move.\
\ls4\ilvl1\kerning1\expnd0\expndtw0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
Your AI should take any available winning move; if none is available, randomly select a losing move.\
\pard\tx1660\tx2160\pardeftab720\li2160\fi-2160\sl680\sa100\partightenfactor0
\ls4\ilvl2\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u9642 	}\expnd0\expndtw0\kerning0
See if you can improve your AI by computing the entire tree of possible moves from the current position. Choose the move that leaves the fewest losers and the most winners in the tree.\
}