{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Georgia;\f2\fmodern\fcharset0 Courier;
\f3\fnil\fcharset0 Consolas;\f4\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red0\green0\blue0;
\red246\green246\blue239;\red34\green34\blue34;\red157\green101\blue255;\red88\green209\blue235;\red100\green108\blue125;
\red0\green0\blue0;\red246\green246\blue239;\red34\green34\blue34;\red157\green101\blue255;\red88\green209\blue235;
\red100\green108\blue125;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0\c7451;
\cssrgb\c97255\c97255\c94902;\cssrgb\c17647\c17647\c17647;\cssrgb\c68235\c50588\c100000;\cssrgb\c40000\c85098\c93725;\cssrgb\c46667\c50196\c56471;
\cssrgb\c0\c0\c0\c7451;\cssrgb\c97255\c97255\c94902;\cssrgb\c17647\c17647\c17647;\cssrgb\c68235\c50588\c100000;\cssrgb\c40000\c85098\c93725;
\cssrgb\c46667\c50196\c56471;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww9100\viewh15500\viewkind0
\deftab720
\pard\pardeftab720\li840\ri840\sl860\sa400\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
Knight's Travails\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\fs40 \cf2 Read through all the instructions before beginning!
\b0 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 Learning Goals\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl440\sa100\partightenfactor0
\ls1\ilvl0
\f1\b0\fs40 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Be able to implement your PolyTreeNode to build a path from start to finish\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Know how to store and traverse a tree\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Know when and why to use BFS vs. DFS\cb1 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 \cb3 Phase 0: Description\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 In this project we will create a class that will find the shortest path for a Chess Knight from a starting position to an end position. Both the start and end positions should be on a standard 8x8 chess board.\

\b NB
\b0 : this problem is a lot like word chains!\
Write a class,\'a0
\f2 \cb4 KnightPathFinder
\f1 \cb3 . Initialize your\'a0
\f2 \cb4 KnightPathFinder
\f1 \cb3 \'a0with a starting position. For instance:\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf5 \cb6 kpf 
\f4 =
\f3  
\f4 \cf7 KnightPathFinder\cf5 .\cf8 new\cf5 ([\cf7 0\cf5 ,
\f3  
\f4 \cf7 0\cf5 ])
\f3 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\fs40 \cf2 \cb3 Ultimately, I want to be able to find paths to end positions:\
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf5 \cb6 kpf
\f4 .
\f3 find_path
\f4 ([\cf7 2\cf5 ,
\f3  
\f4 \cf7 1\cf5 ])
\f3  
\f4 \cf9 # => [[0, 0], [2, 1]]
\f3 \cf5 \
kpf
\f4 .
\f3 find_path
\f4 ([\cf7 3\cf5 ,
\f3  
\f4 \cf7 3\cf5 ])
\f3  
\f4 \cf9 # => [[0, 0], [2, 1], [3, 3]]
\f3 \cf5 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\fs40 \cf2 \cb3 To help us find paths, we will build a\'a0
\b move tree
\b0 . The values in the tree will be positions. A node is a child of another node if you can move from the parent position directly to the child position. The root node of the tree should be the knight's starting position.\'a0
\b You will want to build on your\'a0
\f2\b0 \cb4 PolyTreeNode
\f1\b \cb3 \'a0work, using\'a0
\f2\b0 \cb4 PolyTreeNode
\f1\b \cb3 \'a0instances to represent each position.
\b0 \
Start by creating an instance variable,\'a0
\f2 \cb4 self.root_node
\f1 \cb3 \'a0that stores the knight's initial position in an instance of your\'a0
\f2 \cb4 PolyTreeNode
\f1 \cb3 \'a0class.\
You will be writing an instance method\'a0
\f2 \cb4 KnightPathFinder#build_move_tree
\f1 \cb3 \'a0to build the move tree, beginning with\'a0
\f2 \cb4 self.root_node
\f1 \cb3 . Call this method in\'a0
\f2 \cb4 initialize
\f1 \cb3 ; You will traverse the move tree whenever\'a0
\f2 \cb4 #find_path
\f1 \cb3 \'a0is called.\'a0
\b Don't write this yet though
\b0 .\
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 Phase I:\'a0
\f2\b0 \cb4 #new_move_positions
\f0\b \cb3 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Before we start\'a0
\f2 \cb4 #build_move_tree
\f1 \cb3 , you'll want to be able to find new positions you can move to from a given position. Write a\'a0
\b class
\b0 \'a0method\'a0
\f2 \cb4 KnightPathFinder::valid_moves(pos)
\f1 \cb3 . There are up to eight possible moves.\
You'll also want to avoid repeating positions in the move tree. For instance, we don't want to infinitely explore moving betweeen the same two positions. Add an instance variable,\'a0
\f2 \cb4 @considered_positions
\f1 \cb3 \'a0to keep track of the positions you have considered; initialize it to the array containing just the starting pos. Write an\'a0
\b instance
\b0 \'a0method\'a0
\f2 \cb4 #new_move_positions(pos)
\f1 \cb3 ; this should call the\'a0
\f2 \cb4 ::valid_moves
\f1 \cb3 \'a0class method, but filter out any positions that are already in\'a0
\f2 \cb4 @considered_positions
\f1 \cb3 . It should then add the remaining new positions to\'a0
\f2 \cb4 @considered_positions
\f1 \cb3 \'a0and\'a0
\b return
\b0 \'a0these new positions.\
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 Phase II:\'a0
\f2\b0 \cb4 #build_move_tree
\f0\b \cb3 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Let's return to\'a0
\f2 \cb4 #build_move_tree
\f1 \cb3 . We'll use our\'a0
\f2 \cb4 #new_move_positions
\f1 \cb3 \'a0instance method.\
To ensure that your tree represents only the shortest path to a given position, build your tree in a\'a0
\b breadth-first
\b0 \'a0manner. Take inspiration from your BFS algorithm: use a queue to process nodes in FIFO order. Start with a root node representing the\'a0
\f2 \cb4 start_pos
\f1 \cb3 \'a0and explore moves from one position at a time.\
Next build nodes representing positions one move away, add these to the queue. Then take the next node from the queue... until the queue is empty.\
When you have completed, and tested,\'a0
\f2 \cb4 #build_move_tree
\f1 \cb3 \'a0
\b get a code review from your TA
\b0 .\
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 Head to Part 2!\
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 Once you are finished with phases 1 & 2 head over to Part Two.\
\
\
\pard\pardeftab720\li840\ri840\sl860\sa400\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \outl0\strokewidth0 \strokec2 Knight's Trevails Continued (Part 2)\cb1 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\fs60 \cf2 \cb3 Finish Phases I & II before continuing!\cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\fs48 \cf2 \cb3 Phase III:\'a0
\f2\b0 \cb10 #find_path
\f0\b \cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 Now that we have created our internal data structure (the move tree stored in\'a0
\f2 \cb10 self.root_node
\f1 \cb3 ), we can traverse it to find the shortest path to any position on the board from our original\'a0
\f2 \cb10 @start_pos
\f1 \cb3 .\cb1 \
\cb3 Create an instance method\'a0
\f2 \cb10 #find_path(end_pos)
\f1 \cb3 \'a0to search for\'a0
\f2 \cb10 end_pos
\f1 \cb3 \'a0in the move tree. You can use either\'a0
\f2 \cb10 dfs
\f1 \cb3 \'a0or\'a0
\f2 \cb10 bfs
\f1 \cb3 \'a0search methods from the PolyTreeNode exercises; it doesn't matter. This should return the tree node instance containing\'a0
\f2 \cb10 end_pos
\f1 \cb3 .\cb1 \
\cb3 This gives us a node, but not a path. Lastly, add a method\'a0
\f2 \cb10 #trace_path_back
\f1 \cb3 \'a0to\'a0
\f2 \cb10 KnightPathFinder
\f1 \cb3 . This should trace back from the node to the root using\'a0
\f2 \cb10 PolyTreeNode#parent
\f1 \cb3 . As it goes up-and-up toward the root, it should add each value to an array.\'a0
\f2 \cb10 #trace_path_back
\f1 \cb3 \'a0should\'a0
\b return
\b0 \'a0the values in order from the start position to the end position.\cb1 \
\cb3 Use\'a0
\f2 \cb10 #trace_path_back
\f1 \cb3 \'a0to finish up\'a0
\f2 \cb10 #find_path
\f1 \cb3 .\cb1 \
\cb3 Here are some example paths that you can use for testing purposes (yours might not be exactly the same, but should be the same number of steps);\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3\fs32 \cf11 \cb12 \strokec11 kpf 
\f4 =
\f3  
\f4 \cf13 \strokec13 KnightPathFinder\cf11 \strokec11 .\cf14 \strokec14 new\cf11 \strokec11 ([\cf13 \strokec13 0\cf11 \strokec11 ,
\f3  
\f4 \cf13 \strokec13 0\cf11 \strokec11 ])
\f3 \
kpf
\f4 .
\f3 find_path
\f4 ([\cf13 \strokec13 7\cf11 \strokec11 ,
\f3  
\f4 \cf13 \strokec13 6\cf11 \strokec11 ])
\f3  
\f4 \cf15 \strokec15 # => [[0, 0], [1, 2], [2, 4], [3, 6], [5, 5], [7, 6]]
\f3 \cf11 \strokec11 \
kpf
\f4 .
\f3 find_path
\f4 ([\cf13 \strokec13 6\cf11 \strokec11 ,
\f3  
\f4 \cf13 \strokec13 2\cf11 \strokec11 ])
\f3  
\f4 \cf15 \strokec15 # => [[0, 0], [1, 2], [2, 0], [4, 1], [6, 2]]
\f3 \cf11 \strokec11 \
}