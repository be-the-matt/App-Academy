{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Georgia;\f2\fmodern\fcharset0 Courier;
\f3\fswiss\fcharset0 Helvetica-Light;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red0\green0\blue0;
\red10\green92\blue255;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0\c7451;
\cssrgb\c0\c46667\c100000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\li840\ri840\sl860\sa400\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Error Handling Funtime\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 Oh noes, the clever TAs at App Academy made this "super useful" library, but it keeps throwing ugly error messages that are hard to understand. Let's revamp the library to throw more descriptive errors and prevent incorrect usage.\cb1 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 \cb3 Learning Goals\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl680\sa100\partightenfactor0
\ls1\ilvl0
\f1\b0\fs40 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Know how to\'a0
\f2 \cb4 raise
\f1 \cb3 \'a0and\'a0
\f2 \cb4 rescue
\f1 \cb3 \'a0an exception\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Be able to explain how an exception bubbles up after it is raised\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Know when to use\'a0
\f2 \cb4 ensure
\f1 \cb3 \'a0and\'a0
\f2 \cb4 retry
\f1 \cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Be able to choose an appropriate exception class\cb1 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 \cb3 Phase 1: Setup\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 Download the project\'a0{\field{\*\fldinst{HYPERLINK "https://assets.aaonline.io/fullstack/ruby/projects/error_handling_funtime/skeleton.zip"}}{\fldrslt \cf5 \strokec5 skeleton}}. You will primarily be working in\'a0
\f2 \cb4 super_useful.rb
\f1 \cb3 \'a0to improve errors in our library. The user's script, aptly named\'a0
\f2 \cb4 user_script.rb
\f1 \cb3 , will be using the functions and classes defined in\'a0
\f2 \cb4 super_useful.rb
\f1 \cb3 .\cb1 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 \cb3 Phase 2: Make\'a0
\f2\b0 \cb4 convert_to_int
\f0\b \cb3 \'a0more flexible\cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\fs48 \cf2 \cb3 Overview\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 Sometimes we want to return something from our function, even if the desired operation is not possible. This might mean handling potential errors in our own code and returning a suitable replacement, such as\'a0
\f2 \cb4 nil
\f1 \cb3 \'a0or\'a0
\f2 \cb4 -1
\f1 \cb3 \'a0(often used when trying to find the index of a particular element).\cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 Instructions\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 We want our dear user to be able to call\'a0
\f2 \cb4 convert_to_int
\f1 \cb3 \'a0with no error being raised on invalid input. Update\'a0
\f2 \cb4 convert_to_int
\f1 \cb3 \'a0to\'a0
\f2 \cb4 rescue
\f1 \cb3 \'a0any errors and return\'a0
\f2 \cb4 nil
\f1 \cb3 \'a0if our argument cannot be converted.\cb1 \
\cb3 If we are handling the error thrown by\'a0
\f2 \cb4 Integer(arg)
\f1 \cb3 , which\'a0{\field{\*\fldinst{HYPERLINK "https://ruby-doc.org/core-2.2.0/Exception.html"}}{\fldrslt \cf5 \strokec5 StandardError\'a0subclass}}\'a0should we be catching? Next, update\'a0
\f2 \cb4 convert_to_int
\f1 \cb3 \'a0again to only rescue the correct exception type.\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\b \cf2 \cb3 NB:
\b0 \'a0
\f2 \cb4 rescue
\f1 \cb3 \'a0only\'a0
\i rescues
\i0 \'a0
\f2 \cb4 StandardError
\f1 \cb3 \'a0and its subclasses. Any other\'a0
\f2 \cb4 Exception
\f1 \cb3 \'a0subclass is a system error and implies that something rather serious has gone wrong and our code should stop executing.\cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 Recap\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 Many times we will want to 'protect' the user from potential errors our code might throw. In this case we are protecting our user\'a0
\i only
\i0 \'a0from errors we expect. It is always wise to raise and rescue more specific errors as the errors they raise are more descriptive (helpful with debugging) and it prevents the catching of errors that should 'escape' up to the calling function (catching\'a0
\f2 \cb4 Exception
\f1 \cb3 \'a0will even ignore system errors).\cb1 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 \cb3 Phase 3: Make friendly monster (maybe) let you try again\cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\fs48 \cf2 \cb3 Overview\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 Sometimes when an error is thrown we would like to try the failing operation again (hopefully with different input :wink:). This is often the case with user input and text parsing. Let's try to make friendly monster happy by allowing us to retry feeding it a fruit when certain errors are thrown.\cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 Instructions\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 Friendly monster is\'a0
\i really
\i0 \'a0friendly and\'a0
\i really
\i0 \'a0likes coffee, so he'd like to give us another try, but only when we give him\'a0
\f2 \cb4 "coffee"
\f1 \cb3 .\cb1 \
\cb3 First, handle the errors being thrown by\'a0
\f2 \cb4 #reaction
\f1 \cb3 \'a0in\'a0
\f2 \cb4 #feed_me_a_fruit
\f1 \cb3 .\cb1 \
\cb3 Note that\'a0
\f2 \cb4 #reaction
\f1 \cb3 \'a0throws errors receiving an argument that is not in\'a0
\f2 \cb4 FRUITS
\f1 \cb3 . Next, let's differentiate the errors thrown so our calling function,\'a0
\f2 \cb4 #feed_me_a_fruit
\f1 \cb3 \'a0can try to feed friendly monster again, but only when they've given it coffee.\cb1 \
\cb3 Now that we have different error types being thrown by\'a0
\f2 \cb4 #reaction
\f1 \cb3 \'a0we can do a little conditional logic in\'a0
\f2 \cb4 #feed_me_a_fruit
\f1 \cb3 \'a0to\'a0
\f2 \cb4 retry
\f1 \cb3 \'a0the failing block of code again, but only if it is a coffee-related error.\cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 Recap\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 Being able to rescue and retry failing code gives us even more control over the flow of our program. Handling different errors separately gives us even more control.\cb1 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 \cb3 Phase 4: Ensure\'a0
\f2\b0 \cb4 BestFriend
\f0\b \cb3 \'a0is a real best friend\cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\fs48 \cf2 \cb3 Overview\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 Another use case for raising errors is to enforce correct usage of code. For example, if a function requires its arguments to be of certain types in order to execute properly, it might be best to check their type before executing any logic. This is useful because it allows us to inform the user that they are not using our function properly, rather than a runtime error being raised which may seem like a bug in our code or be more difficult to debug.\cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 Instructions\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 If we look at\'a0
\f2 \cb4 user_script.rb
\f1 \cb3 , we see that our dear user thinks you can be besties if you've known each other less than a year. We do not agree. Friendships, like a fine wine, need at least five years to mature. Update\'a0
\f2 \cb4 BestFriend#initialize
\f1 \cb3 , in\'a0
\f2 \cb4 super_useful.rb
\f1 \cb3 , to raise a descriptive error when\'a0
\f2 \cb4 yrs_known
\f1 \cb3 \'a0is less than\'a0
\f2 \cb4 5
\f1 \cb3 .\cb1 \
\cb3 Test your code, then assume the role of our dear user and update our call to\'a0
\f2 \cb4 BestFriend#new
\f1 \cb3 \'a0to create a\'a0
\i real
\i0 \'a0friendship (
\f2 \cb4 yrs_known>= 5
\f1 \cb3 ).\cb1 \
\cb3 Our dear user also thinks it's okay to leave\'a0
\f2 \cb4 name
\f1 \cb3 \'a0and\'a0
\f2 \cb4 fav_pastime
\f1 \cb3 \'a0empty when creating a new instance of\'a0
\f2 \cb4 BestFriend
\f1 \cb3 . But it's not okay. It leaves\'a0
\f2 \cb4 #do_friendstuff
\f1 \cb3 \'a0and\'a0
\f2 \cb4 #give_friendship_bracelet
\f1 \cb3 \'a0sorely lacking. Poorly formatted text just makes us seethe with displeasure. Update the\'a0
\f2 \cb4 initialize
\f1 \cb3 \'a0method to raise descriptive errors when given strings of\'a0
\f2 \cb4 length <= 0
\f1 \cb3 .\cb1 \
\cb3 Test your code, then again assume the role of our dear user and update our call to\'a0
\f2 \cb4 BestFriend#new
\f1 \cb3 .\cb1 \
\pard\pardeftab720\li840\ri840\sl560\sa400\partightenfactor0

\f0\b\fs48 \cf2 \cb3 Recap\cb1 \
\pard\pardeftab720\li840\ri840\sl600\sa400\partightenfactor0

\f1\b0\fs40 \cf2 \cb3 Raising errors for invalid arguments can ensure that our code is used the way we want intend. However, be aware that the types of inputs we can receive are numerous. We don't want or need to be checking against every possible type for each argument we receive.\cb1 \
\pard\pardeftab720\li840\ri840\sl720\sa400\partightenfactor0

\f0\b\fs60 \cf2 \cb3 Resources\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl680\sa100\partightenfactor0
\ls2\ilvl0
\f1\b0\fs40 \cf5 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://open.appacademy.io/learn/full-stack-online/ruby/exceptions--error-handling"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 Exceptions/Error Handling reading}}\cf2 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
\ls2\ilvl0\cf5 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "http://www.skorks.com/2009/09/ruby-exceptions-and-exception-handling/"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 Skorks on exceptions}}\cf2 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
\ls2\ilvl0\cf5 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://github.com/adomokos/DesignPatterns-Ruby/"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 Ruby Patterns}}\cf2 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
\pard\pardeftab720\sl280\partightenfactor0

\f3\fs24\fsmilli12250 \cf2 \
}